# 二分查找（存在重复元素情况）

```java
int binarySearchInsertion(int[] nums, int target) {
    int i = 0, j = nums.length- 1; // 初始化双闭区间 [0, n-1]
    while (i <= j) {
        int m = i + (j- i) / 2; // 计算中点索引 m
        if (nums[m] < target) {
            i = m + 1; // target 在区间 [m+1, j] 中
        } else if (nums[m] > target) {
            j = m- 1; // target 在区间 [i, m-1] 中
        } else {
            j = m- 1; // 首个小于 target 的元素在区间 [i, m-1] 中
        }
    }
    // 返回插入点 i
    return i;
}
```

# 快速排序

```java
void swap(int[] nums, int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}
int partition(int[] nums, int left, int right) {
    // 以 nums[left] 为基准数
    int i = left, j = right;
    while (i < j) {
        while (i < j && nums[j] >= nums[left]){
            j--;
        }
        while (i < j && nums[i] <= nums[left]){
            i++;
        }
        swap(nums, i, j);
    }
    swap(nums, i, left);
    return i;
}
void quickSort(int[] nums, int left, int right) {
    // 子数组长度为 1 时终止递归
    if (left >= right){
        return;
    }
    // 哨兵划分
    int pivot = partition(nums, left, right);
    // 递归左子数组、右子数组
    quickSort(nums, left, pivot- 1);
    quickSort(nums, pivot + 1, right);
}
```

